'''
Flow of the pipeline:
1. Find path of the images and create a list of Image objects.
2. Load the images using the specified library.
3. Ask the LLm for alias of the classes.
4. use the alias generated to predict the bbox of the images.

'''

import os
import concurrent.futures

from image import Image
from metrics import Metrics
from model_llm import LLM
from alias import Alias
from dataset import Dataset
from model_vis import ModelVis

from log import Log
from icecream import ic
import argparse
import re

LABEL_PATTERN = re.compile(r'".*?"') # Pattern to find the labels in the text

classes = {
    "bitter pack" : 0,
    "bottle pack" : 1,
    "box" : 2,
    "can pack" : 3,
    "crate" : 4,
    "keg" : 5,
}


def generate_text(class_name: str) -> str:
    """
    Generate text for the given class name.

    Args:
        class_name (str): class name ("box", ...).

    Returns:
        str: label generated by the model.
    """
    options = {
        "max_length": 2048,
        "min_length": 1,
        "do_sample": False,
        "top_p": 0.9,
        "top_k": 0,
        "temperature": 0.2,
        "repetition_penalty": 1.0,
    }
    model_path = LLM.model_path()
    try:
        model = LLM(model_path, options)
    except Exception as e:
        print("Model not found, downloading ...")
        try:
            model_path = LLM.download_model()
        except Exception as e:
            print("Error downloading model:", e)
            return
        print("Model downloaded")
        model = LLM(model_path, options)

    if not os.path.exists("../data/json"):
        os.mkdir("../data/json")

    history_file = f"../data/json/history_{class_name}.json"
    history_ = LLM.load_history(history_file)

    text = f"I have to find the best alias for this word: '{class_name}'. Could you give me a new alias?"

    try:
        old_labels = LLM.get_old_labels(history_)
        old_labels = list(set(old_labels))
    except Exception as e:
        with open("../data/json/examples.txt", "r") as f:
            examples = f.readlines()
        old_labels = [example.strip().split(",")[1] for example in examples]

    processed_text = model.process_input(text, history_, old_labels)
    new_text = model.generate(processed_text)
    # print(new_text)

    LLM.write_history(text, new_text, history_file, history_)

    return LABEL_PATTERN.findall(new_text.split("\n")[0])[0]


def process_class(list_of_images: list[Image], class_name: str, num_alias: int):
    for num in range(num_alias):
        try:
            alias = generate_text(class_name)
            ic(f"Generated alias for class {class_name}: {alias}")
        except Exception as e:
            ic(f"Error generating text: {e}")
            logger.write_error(e)
            continue

        list_of_gt = [image.get_ground_truth() for image in list_of_images]

        model_vis = ModelVis(list_of_images, list_of_gt)
        confidence_scores = model_vis.predict(alias)

        metrics = Metrics(confidence_scores)
        mean_auc_score, results = metrics.get_precision_recall()

        alias = Alias(alias, classes[class_name], results)
        

    pass


def args_parsing():
    parser = argparse.ArgumentParser(description='Process some integers.')
    parser.add_argument('-i', '--indir', type=str, help='Input image path')
    parser.add_argument('-a', '--alias', type=int, help='Num of alias for each class')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose mode')
    args = parser.parse_args()
    return args


def main(logger: object):
    args = args_parsing()

    if args.verbose:
        ic.enable()
    else:
        ic.disable()

    dataset = Dataset()
    images_path_list = dataset.images_dir(args.indir)   # '../data/images'
    image_list = [Image(image_path) for image_path in images_path_list]  # Create a list of Image objects
   
    for image in image_list:
        try:
            image.load('jpeg4py')
            ic(image.image)
        except AttributeError as e:
            print(f"Error loading image: {e}")
            logger.write_error(e)
            break
        except Exception as e:
            print(f"Error loading image: {e}")
            logger.write_error(e)
            continue

    with concurrent.futures.ProcessPoolExecutor() as executor:
        futures = [executor.submit(process_class, image_list, class_name, args.alias) for class_name in classes]
        for future in concurrent.futures.as_completed(futures):
            try:
                future.result()
            except Exception as e:
                logger.write_error(f"Exception during class processing: {e}")


    pass


if __name__ == "__main__":
    nome_f = os.path.basename(__file__)
    logger = Log(nome_f)
    logger.log(False)
    main(logger)
    logger.log(True)

